本篇文章，我们来说一说`Vue`里面的双向数据绑定。因为`Vue`处理的东西比较多，比较复杂，我们先用一个自己写的小demo演示一下它的大概思路是什么。

`Vue`里面的数据绑定是通过数据劫持的方式来实现的，其中最核心的便是`Object.defineProperty()`，不熟悉这个方法的，建议先去学习一下相关的内容，这里就不再赘述。

双向数据绑定，简单点来说分为三个部分：

* 1、`Observer`。这里的主要工作是递归地监听对象上的所有属性，在属性值改变的时候，触发相应的`watcher`。

* 2、`Watcher`。观察者，当监听的数据值修改时，执行响应的回调函数（`Vue`里面的更新模板内容）。

* 3、`Dep`。连接`Observer`和`Watcher`的桥梁，每一个`Observer`对应一个`Dep`，它内部维护一个数组，保存与该`Observer`相关的`Watcher`。

## 数据绑定demo

接下来，先看我们极其简化的小demo。

第一部分是`Observer`。

```JavaScript
function Observer(obj, key, value){
	var dep = new Dep();
	if (Object.prototype.toString.call(value) == '[object Object]') {
		Object.keys(value).forEach(function(key){
			new Observer(value,key,value[key])
		})
	};

	Object.defineProperty(obj, key, {
		enumerable: true,
    	configurable: true,
    	get: function(){
    		if (Dep.target) {
    			dep.addSub(Dep.target);
    		};
    		return value;
    	},
    	set: function(newVal){
    		value = newVal;
    		dep.notify();
    	}
	})
}
```
这里我们先略过对数组的处理等。递归地为`obj`的每个属性添加`getter`和`setter`。在`getter`中，我们把`watcher`添加到`dep`中。`setter`中，触发`watcher`执行回调。

第二部分是`Watcher`。

```
function Watcher(fn){
	this.update = function(){
		Dep.target = this;
		fn();
		Dep.target = null;
	}
	this.update();
}
```
极其简单的几行代码，`fn`是数据变化后要执行的回调函数，一般是获取数据渲染模板。默认执行一遍`update`方法是为了在渲染模板过程中，调用数据对象的`getter`时建立两者之间的关系。因为同一时刻只有一个`watcher`处于激活状态，把当前`watcher`绑定在`Dep.target`（方便在`Observer`内获取）。回调结束后，销毁`Dep.target`。

最后是`Dep`。

```
function Dep(){
	this.subs = [];

	this.addSub = function (watcher) {
		this.subs.push(watcher);
	}

	this.notify = function(){
		this.subs.forEach(function(watcher){
			watcher.update();
		});
	}
}
```

内部一个存放`watcher`的数组`subs`。`addSub`用于向数组中添加`watcher`(`getter`时)。`notify`用于触发`watcher`的更新(`setter`时)。

以上就是我们简易的双向数据绑定demo。我们看看用起来是什么样的。

```
<div id="test"></div>
<script type="text/javascript">
	var obj = {
		a: 1,
		b: 2,
		c: 3
	}
	Object.keys(obj).forEach(function(key){
		new Observer(obj, key, obj[key])
	});
	new Watcher(function(){
		document.querySelector("#test").innerHTML = obj.a;
	})
</script>
```
首先，我们给`obj`的每一个属性都添加`getter`和`setter`。创建一个`Watcher`对象，回调函数是使`#test`的内容为`obj.a`，这里是`1`。

打开控制太，我们修改`obj.a == 22`。我们发现页面中显示的内容也变成了`22`。相关代码见[这里]()。

以上知识我们的开胃小菜，`Vue`中对数组做了处理，而且页面的更新是异步执行的，所以会有许许多多的处理，接下来我们慢慢分解。

## `Vue`中的双向绑定

我们先看一张图，这是Vue文档中的一张图，解释的就是`Vue`的响应式原理。

(vue数据绑定)[https://cn.vuejs.org/images/data.png]

整体上和我们之前的demo一样，我们之前说过，`Vue`的更新是生成`render`函数，然后生成虚拟`dom`，映射到页面上。左侧的部分其实就是我们`watcher`的回调，右下角的`data`就是通过我们上面说的`Observer`来添加`getter`和`setter`。`watcher`通过`dependency`和`data`联系在一起，并触发`re-render`。

## `Vue`中的`Observer`

接着，我们来看源码，打开`src/core/observer/index.js`。

首先是我们的`Observer`对象。

```
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // 把该对象作为root $data的vm个数

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    // 添加__ob__来标示value有对应的Observer
    def(value, '__ob__', this)
    // 对数组的处理
    if (Array.isArray(value)) {
      const augment = hasProto
        ? protoAugment
        : copyAugment
      augment(value, arrayMethods, arrayKeys)
      this.observeArray(value)
    // 处理对象
    } else {
      this.walk(value)
    }
  }

  // 给每个属性添加getter/setters
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  // 观察数组的每一项
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

```